diff --git a/lib/handshake.c b/lib/handshake.c
index ebea926aa..8dce170fe 100644
--- a/lib/handshake.c
+++ b/lib/handshake.c
@@ -248,6 +248,7 @@ int _gnutls_set_server_random(gnutls_session_t session, const version_entry_st *
 	memcpy(session->security_parameters.server_random, rnd,
 	       GNUTLS_RANDOM_SIZE);
 
+#if 0 /* This was not supposed to be checked in draft-versions */
 	/* check whether the server random value is set according to
 	 * to TLS 1.3. p4.1.3 requirements */
 	if (!IS_DTLS(session) && vers->id <= GNUTLS_TLS1_2 && have_creds_for_tls13(session)) {
@@ -272,6 +273,7 @@ int _gnutls_set_server_random(gnutls_session_t session, const version_entry_st *
 			return gnutls_assert_val(GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER);
 		}
 	}
+#endif
 
 	return 0;
 }
@@ -291,6 +293,7 @@ int _gnutls_gen_server_random(gnutls_session_t session, int version)
 
 	max = _gnutls_version_max(session);
 
+#if 0
 	if (!IS_DTLS(session) && max->id >= GNUTLS_TLS1_3 &&
 	    version <= GNUTLS_TLS1_2) {
 		if (version == GNUTLS_TLS1_2) {
@@ -303,7 +306,9 @@ int _gnutls_gen_server_random(gnutls_session_t session, int version)
 		ret =
 		    gnutls_rnd(GNUTLS_RND_NONCE, session->security_parameters.server_random, GNUTLS_RANDOM_SIZE-8);
 
-	} else {
+	} else
+#endif
+	{
 		ret =
 		    gnutls_rnd(GNUTLS_RND_NONCE, session->security_parameters.server_random, GNUTLS_RANDOM_SIZE);
 	}
diff --git a/tests/tls13/rnd-check-rollback-val.c b/tests/tls13/rnd-check-rollback-val.c
index f573596c5..6934b2507 100644
--- a/tests/tls13/rnd-check-rollback-val.c
+++ b/tests/tls13/rnd-check-rollback-val.c
@@ -222,6 +222,8 @@ void doit(void)
 	int ret;
 	pid_t child;
 
+	exit(77);
+
 	signal(SIGCHLD, ch_handler);
 	signal(SIGPIPE, SIG_IGN);
 
diff --git a/tests/tls13/rnd-rollback-detection.c b/tests/tls13/rnd-rollback-detection.c
index 0d1ef0149..8cbb658cf 100644
--- a/tests/tls13/rnd-rollback-detection.c
+++ b/tests/tls13/rnd-rollback-detection.c
@@ -206,6 +206,8 @@ void doit(void)
 	int ret;
 	pid_t child;
 
+	exit(77);
+
 	signal(SIGCHLD, ch_handler);
 	signal(SIGPIPE, SIG_IGN);
 
